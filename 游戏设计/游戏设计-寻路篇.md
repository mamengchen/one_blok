---
title: 游戏设计-寻路篇
tags: 算法,设计,C++
category: /小书匠/日记/2024-10
grammar_cjkRuby: true
---


寻路算法（）是用于寻找从一个起点到一个终点的最优路径的算法，广泛应用于地图导航、游戏开发、机器人路径规划等领域。

---------
## 1.设计寻路相关的算法分析
### 1.1.广度优先搜索（Breadth-First Search, BFS）
BFS 是一种图遍历算法，通过逐层扩展节点，适用于寻找无权图（即每条边的权重相同）的最短路径。
<font color = "red">特点：
1.原理：从起点开始，逐层访问邻近节点，直到找到终点。
2.适用场景：用于无权图中的最短路径寻找，或者路径权重相等的情况中。
3.时间复杂度：O（V+E），其中V是顶点数，E是边数。
4.空间复杂度：O（V），需要记录所有节点的访问状态。</font>
<font>优缺点：能够保证找到最短路径。但是在权重不同的情况下，效率不高，不能处理权重差异。</font>

 ---
 
### 1.2.深度优先搜索（Depth-First Search, DFS）
DFS 是另一种图遍历算法，探索路径时尽量深入。
<font color = "red">特点：
1.原理：从起点开始，沿着一条路径尽可能深入，直到到达终点或者遇到死路，然后回溯并尝试其他路径。
2.适用场景：解决迷宫问题，递归问题等，但不能保证最短路径。
3.时间复杂度：O（V+E）。
4.空间复杂度：O（V）由于递归深度或显式栈的空间。</font>
<font>优缺点：易于实现，可以处理某些图中有环的情况。无法保证找到最短路径，容易陷入死循环</font>

 ---
 
### 1.3.Dijkstra算法
Dijkstra 是一种用于加权图的单源最短路径算法。它能够在图中找到从一个起点到所有其他顶点的最短路径。
<font color = "green">特点：
1.原理：从起点开始，每次选择距离最近的未访问节点进行扩展，更新其邻居的距离，直到访问所有节点或找到终点。
2.适用场景：适用于加权图，特别是边权重非负的情况下。
3.时间复杂度：O（E+VlogV），使用优先队列时。
4.空间复杂度：O（V）。</font>
<font>优缺点：适用于加权图，能够找到从起点到所有其他顶点的最短路径。当存在负权重时，Dijkstra 可能无法得出正确结果。</font>
 
  ---
  
### 1.4. A*算法
A*是一种启发式搜索算法，结合了 Dijkstra 算法和 BFS 的优点，通过启发式函数指导搜索方向。
<font  color = "green">特点：
1.原理：A\*算法使用启发式函数 f(n) = g(n) + h(n)，其中 g(n) 是从起点到当前节点的实际距离， h(n) 是估计的当前节点到终点的距离。每次选择 f(n) 最小的节点进行扩展。
2.适用场景：适用于加权图或网格图，特别是在路径有明确方向或估计较准的情况下。
3.时间复杂度：取决于启发式函数，如果启发式函数准确，</font>