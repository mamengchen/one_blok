---
title: Lua Bridge 原理，以及和C++交互
tags: Lua,游戏,C++
category: /小书匠/日记/2024-09
grammar_cjkRuby: true
---


Lua语言本身是用C语言来编写的虚拟机。当初设计Lua的目的就是想让Lua成为一个很容易嵌入其他语言中使用的语言。现有很多应用程序使用Lua作为自己嵌入式脚本语言，以此实现扩展后期热更。

----------

Lua的特性：它是一门轻量级语言，它的官方版本只包括一个精简的核心和最基本的库。源码是开源的，把源码编译之后仅仅一百多K，可以很方便的嵌入别的程序里。Lua同时也易于扩展，由宿主语言(通常是C或C++，但是也有一些列第三方扩展让他在游戏中发光发热)开发和提供一些功能，Lua可以很容易的使用它们。

## Lua与其他宿主语言交互的桥梁-栈

Lua 中，对虚拟栈提供正向索引和反向索引两种索引方式，区别是：<font color = "orange"><strong>正数索引 1 代表栈底，负数索引 -1 永远表示栈顶。重要！后面所有的交互，都是基于Lua的虚拟栈来</strong></font>

![lua虚拟栈](./images/1725222694263.png)

<font color = "red">**Lua与其他宿主语言的交互，是通过C语言实现的虚拟栈来实现交互的**。</font>Lua 在 C 函数和脚本函数之间创建了一钟虚拟栈的结构，栈的元素代表一个Lua的值(table，string，nil等等8种基本类型)。Lua提供了一系列C API用于操作栈，比如将元素入栈，出栈，删除等等。在调用这些API之前，通常都需要将必须的值压入栈，在API调用结束后，再把结果从栈种取出。

![游戏：C/C++与Lua交互](./images/1725221883437.png)

## C++ 调用Lua函数


## Lua 源码分析

**Lua_newState : 函数在Lua C API 中用于创建一个新的 Lua 状态。它主要负责初始化 Lua 解释器的各种数据结构，并为 Lua 运行时环境分配内存。** 

![Lua_newState源码](./images/1725223922257.png)
>LG* l = cast(LG*, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG))); 
这句代码的作用是利用自定义的内存分配函数为 Lua 的全局状态和 Lua 状态分配内存，并将结果强制转换为指向‘LG’结构体的指针。

![LG结构体](./images/1725224519127.png)
**1. 内存分配函数调用（"（\*f）"）**：\*f  是一个指向内存分配函数的指针，其类型为 ‘lua_Alloc’。这个函数用于管理 Lua 运行时的内存分配。(\*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)) 调用了这个分配函数。
**2. 内存分配函数参数解析**：‘ud’用户数据指针，传递给分配函数。通常用于提供上下文信息，或是在内存管理时使用。第二个参数用‘NULL’是旧内存块的指针，当这个指针为NULL时表示这是一次新内存分配，而不是调整已有内存块的大小。第三个参数 ‘Lua_TTHREAD’告诉分配函数分配的是一个 Lua 线程类型的对象。第四个参数‘sizeof(LG)’为要分配的内存大小。LG 是一个组合结构体，包含了 ‘lua_State’和 ‘global_State’,即它将 Lua 状态和全局状态封装在一起。
**3. 强制类型转换**：‘cast(LG*, ...)’是一个宏定义，通常用来将一个指针类型强制转换为目标类型的指针。在这段代码中，它将分配函数返回的通用指针 （‘void*’）转换为 ‘LG*’类型的指针。
<font color = "red"><strong>作用总结：</strong>这句代码的作用是通过Lua自定义的内存分配器为整个Lua解析器状态（包括全局状态和主线程状态）分配所需的内存，并将这个内存块转换为‘LG’类型的指针。这样做是为了初始化 Lua 解释器的主要数据结构，使其可以运行。LG 包含了 Lua 的全局状态 (global_State) 和主线程的 Lua 状态 (lua_State)，是 Lua 状态初始化的核心。</font>


![后续初始化数据](./images/1725226192997.png)