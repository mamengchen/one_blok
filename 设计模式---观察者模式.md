---
title: 设计模式---观察者模式
tags: C++,改善程序设计,提高代码质量
grammar_cjkRuby: true
---


#### Observer 模式：
这个模式可以说是应用最多，影响最广的模式之一，它用于**建立一种对象于对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。**

#### 模式的定义

观察者模式（Observer Pattern）定义如下：
> 定义对象间的==一种一对多的依赖关系 #9C27B0==，==当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 #673AB7==。当一个对象发生了变化，关注它的对象就会得到通知；这种交互也称为发布-订阅(publish-subscribe)。**目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者**。观察者模式的别名还包括 《模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。》

#### 模式的优点
1、观察者模式（Observer）完美的将观察者和被观察的对象分离开。举个例子，用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，发现数据变化后，就显示在界面上。

2、面向对象设计的一个原则是：==系统中的每个类将重点放在某一个功能上，而不是其他方面 #9C27B0==。一个对象只做一件事情，并且将他做好。观察者模式在模块之间划定了清晰的界限，提高了应用2程序的可维护性和重用性。

3、观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。

4、观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为发布-订阅(Publish-Subscribe)。观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。

#### 模式的应用场景
在以下任意情况下都可以使用观察者模式：

 - 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。**将这二者封装在独立的对象中以使它们可以各自独立的改变和复用**；
 - 当对一个对象的改变需要同时改变其它对象，**而不知道具体有多少对象有待改变**；
 - 当一个对象必须通知其它对象，而它又不能假定其它对象是谁；也就是说，**你不希望这些对象是紧密耦合的**；

#### 模式UML类图分析

![765168-20160814144941875-41772080](./images/765168-20160814144941875-41772080.png)

Subject（目标）

 - 目标知道它的观察者。可以有任意多个观察者观察同一个目标；
 - 提供注册和删除观察者对象的接口。

Observer（观察者）

 - 为那些在目标发生改变时需获得通知的对象定义一个更新接口。

ConcreteSubject（具体目标）

 - 将有关状态存入各ConcreteObserver对象；
 - 当它的状态发生改变时，向它的各个观察者发出通知。

ConcreteObserver（具体观察者）

 - 维护一个指向ConcreteSubject对象的引用；
 - 存储有关状态，这些状态应与目标的状态保持一致；
 - 实现Observer的更新接口以使自身状态与目标的状态保持一致。

观察者模式按照以下方式进行协作：
 1. 当ConcreteSubject发生任可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者；
 2. 在得到一个具体目标的改变通知后，ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。

调用时序图：
![765168-20160814145059437-1060662569](./images/765168-20160814145059437-1060662569.png)

