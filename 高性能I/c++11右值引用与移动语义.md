---
title: [c++11右值引用与移动语义]
---

c++中引入了右值引用和移动语义，可以避免无谓的复制，提高程序性能。

#### 左值、右值
c++中所有的值都必然属于左值、右值二者之一。左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值。

看见书上又将右值分为将亡值和纯右值。纯右值就是c++98标准中右值的概念，如非引用返回的函数返回的临时变量值；一些运算表达式，如1+2产生的临时变量；不跟对象关联的字面量值，如2，'c'，true，"hello"；这些值都不能够被取地址。

而将亡值则是c++11新增的和右值引用相关的表达式，这样的表达式通常时将要移动的对象、T&&函数返回值、std::move()函数的返回值等，

不懂将亡值和纯右值的区别其实没关系，统一看作右值即可，不影响使用。

示例：
![enter description here](./images/1565617137934.png)

#### 左值引用、右值引用

c++98中的引用很常见了，就是给变量取了个别名，在c++11中，因为增加了右值引用(rvalue reference)的概念，所以c++98中的引用都称为了左值引用(lvalue reference)。

![enter description here](./images/1565617163491.png)

c++11中的右值引用使用的符号是&&，如

![enter description here](./images/1565617186207.png)

getTemp()返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量a的生命期一样，只要a还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。

注意：这里a的类型是右值引用类型(int &&)，但是如果从左值和右值的角度区分它，它实际上是个左值。因为可以对它取地址，而且它还有名字，是一个已经命名的右值。

所以，左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。但是，常量左值引用却是个奇葩，它可以算是一个“万能”的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。

![enter description here](./images/1565617244383.png)

事实上，很多情况下我们用来常量左值引用的这个功能却没有意识到，如下面的例子：

![enter description here](./images/1565698426294.png)

当我敲完上面的例子并运行后，发现结果和我想象的完全不一样！期望中AcceptVal(ReturnRvalue())需要调用两次拷贝构造函数，一次在ReturnRvalue()函数中，构造好了Copyable对象，返回的时候会调用拷贝构造函数生成一个临时对象，在调用AcceptVal()时，又会将这个对象拷贝给函数的局部变量a，一共调用了两次拷贝构造函数。而AcceptRef()的不同在于形参是常量左值引用，它能够接收一个右值，而且不需要拷贝。
而实际的结果是，不管哪种方式，一次拷贝构造函数都没有调用！
这是由于编译器默认开启了返回值优化(RVO/NRVO, RVO, Return Value Optimization 返回值优化，或者NRVO， Named Return Value Optimization)。编译器很聪明，发现在ReturnRvalue内部生成了一个对象，返回之后还需要生成一个临时对象调用拷贝构造函数，很麻烦，所以直接优化成了1个对象对象，避免拷贝，而这个临时变量又被赋值给了函数的形参，还是没必要，所以最后这三个变量都用一个变量替代了，不需要调用拷贝构造函数。
虽然各大厂家的编译器都已经都有了这个优化，但是这并不是c++标准规定的，而且不是所有的返回值都能够被优化，而这篇文章的主要讲的右值引用，移动语义可以解决编译器无法解决的问题。
为了更好的观察结果，可以在编译的时候加上-fno-elide-constructors选项(关闭返回值优化)。

![enter description here](./images/1565698463121.png)

上面这个例子本意是想说明常量左值引用能够绑定一个右值，可以减少一次拷贝（使用非常量的左值引用会编译失败），但是顺便讲到了编译器的返回值优化。。编译器还是干了很多事情的，很有用，但不能过于依赖，因为你也不确定它什么时候优化了什么时候没优化。

总结：
1.左值引用， 使用 T&, 只能绑定左值 
2.右值引用， 使用 T&&， 只能绑定右值 
3.常量左值， 使用 const T&, 既可以绑定左值又可以绑定右值 
4.已命名的右值引用，编译器会认为是个左值 
5.编译器有返回值优化，但不要过于依赖

#### 移动构造和移动赋值

回顾一下如何用c++实现一个字符串类MyString，MyString内部管理一个C语言的char * 数组，这个时候一般都需要实现拷贝构造函数和拷贝赋值函数，因为默认的拷贝是浅拷贝，而指针这种资源不能共享，不然一个析构了，另一个也就完蛋了。

具体代码如下：
![enter description here](./images/1565699147033.png)
![enter description here](./images/1565699164104.png)

代码看起来挺不错，却发现执行了1000次拷贝构造函数，如果MyString("hello")构造出来的字符串本来就很长，构造一遍就很耗时了，最后却还要拷贝一遍，而MyString("hello")只是临时对象，拷贝完就没什么用了，这就造成了没有意义的资源申请和释放操作，如果能够直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间。而C++11新增加的移动语义就能够做到这一点。
要实现移动语义就必须增加两个函数：移动构造函数和移动赋值构造函数。
